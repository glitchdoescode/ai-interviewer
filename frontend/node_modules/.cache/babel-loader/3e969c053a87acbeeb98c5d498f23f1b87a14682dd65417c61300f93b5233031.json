{"ast":null,"code":"import{useState,useEffect,useCallback,useRef}from'react';import Recorder from'recorder-js';/**\n * Custom hook for audio recording functionality\n * @returns {Object} Object containing recording state and functions\n */const useAudioRecorder=()=>{const[recorder,setRecorder]=useState(null);const[stream,setStream]=useState(null);const[isRecording,setIsRecording]=useState(false);const[audioData,setAudioData]=useState(null);const[error,setError]=useState(null);const[audioContext,setAudioContext]=useState(null);const[permissionGranted,setPermissionGranted]=useState(false);const[isInitializing,setIsInitializing]=useState(false);const recorderRef=useRef(null);const audioContextRef=useRef(null);const streamRef=useRef(null);// Check if we're on a mobile device\nconst isMobile=useRef(/iPhone|iPad|iPod|Android/i.test(navigator.userAgent));// Clean up audio resources when the component unmounts\nuseEffect(()=>{return()=>{// Clean up function\nconst cleanupResources=()=>{console.log(\"DEBUG: Cleaning up audio resources\");// Stop all tracks in the stream if it exists\nif(streamRef.current){streamRef.current.getTracks().forEach(track=>{console.log(`DEBUG: Stopping track: ${track.kind}`);track.stop();});streamRef.current=null;}// Close audio context if it exists\nif(audioContextRef.current&&audioContextRef.current.state!=='closed'){console.log(`DEBUG: Closing AudioContext (state: ${audioContextRef.current.state})`);audioContextRef.current.close().catch(err=>{console.error(\"DEBUG: Error closing AudioContext:\",err);});audioContextRef.current=null;}// Release recorder resources if any\nif(recorderRef.current){console.log(\"DEBUG: Cleaning up recorder\");recorderRef.current=null;}// Clear state\nsetStream(null);setRecorder(null);setAudioContext(null);setIsRecording(false);};try{cleanupResources();}catch(err){console.error(\"DEBUG: Error during cleanup:\",err);}};},[]);// Helper function to unlock audio context (especially on mobile)\nconst unlockAudioContext=useCallback(async context=>{console.log(`DEBUG: Attempting to unlock AudioContext (state: ${context.state})`);if(context.state==='suspended'){// Create and play a silent sound (crucial for iOS)\ntry{const buffer=context.createBuffer(1,1,22050);const source=context.createBufferSource();source.buffer=buffer;source.connect(context.destination);source.start(0);// Try user interaction simulation for Safari/iOS\nif(isMobile.current){console.log(\"DEBUG: Applying mobile-specific audio unlocking\");// Use both timeout and direct resume for better chances\nsetTimeout(()=>{context.resume().catch(e=>console.log(\"DEBUG: Delayed resume failed:\",e));},100);// Some browsers need direct user gesture to work\ndocument.documentElement.addEventListener('touchend',function unlock(){context.resume().then(()=>{document.documentElement.removeEventListener('touchend',unlock);console.log(\"DEBUG: TouchEnd unlocked AudioContext\");}).catch(e=>console.log(\"DEBUG: TouchEnd resume failed:\",e));},{once:true});}console.log(\"DEBUG: Direct resume attempt\");await context.resume();console.log(`DEBUG: AudioContext after unlock attempt: ${context.state}`);return context.state==='running';}catch(err){console.error(\"DEBUG: Error unlocking audio context:\",err);return false;}}return context.state==='running';},[]);// Initialize audio recording with clearer error handling\nconst initRecording=useCallback(async()=>{// Prevent multiple initializations\nif(isInitializing){console.log('DEBUG: Already initializing audio...');return false;}try{setIsInitializing(true);setError(null);console.log('DEBUG: Requesting microphone permission...');// Request user permission to access the microphone\nconst audioStream=await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:true,noiseSuppression:true,autoGainControl:true}});console.log('DEBUG: Microphone permission granted, got stream:',!!audioStream);setStream(audioStream);streamRef.current=audioStream;setPermissionGranted(true);console.log('DEBUG: Creating audio context...');// Create an audio context\nlet context;try{// Safari requires prefix\nconst AudioContext=window.AudioContext||window.webkitAudioContext;context=new AudioContext();console.log('DEBUG: Audio context created, state:',context.state);// Ensure the context is running\nif(context.state!=='running'){console.log('DEBUG: Audio context not running, attempting to unlock...');await unlockAudioContext(context);}// Store the context references\nsetAudioContext(context);audioContextRef.current=context;// Create a new recorder with the audio context\nconsole.log('DEBUG: Creating recorder instance...');const newRecorder=new Recorder(context);// Connect the recorder to the stream\nconsole.log('DEBUG: Initializing recorder with stream...');await newRecorder.init(audioStream);console.log('DEBUG: Recorder initialized successfully');// Store the recorder references\nsetRecorder(newRecorder);recorderRef.current=newRecorder;console.log('DEBUG: Audio recording setup complete');return true;}catch(contextError){console.error('DEBUG: Error with audio context:',contextError);// Try to release the stream since we failed\nif(streamRef.current){streamRef.current.getTracks().forEach(track=>track.stop());}throw contextError;}}catch(err){console.error('DEBUG: Error initializing audio recording:',err.name,err.message);// Provide specific error messages based on the error type\nif(err.name==='NotAllowedError'){setError('Microphone permission denied. Please allow access in your browser settings.');}else if(err.name==='NotFoundError'){setError('No microphone detected. Please check your device settings.');}else if(err.name==='AbortError'){setError('Recording permission request was aborted. Please try again.');}else if(err.name==='NotReadableError'){setError('Microphone is already in use by another application.');}else if(err.name==='SecurityError'){setError('Security error accessing microphone. Try using HTTPS.');}else{setError(`Error accessing microphone: ${err.message}`);}return false;}finally{setIsInitializing(false);}},[isInitializing,unlockAudioContext]);// Start recording with improved error handling\nconst startRecording=useCallback(async()=>{try{setError(null);// Using refs to avoid timing issues with state updates\nlet currentRecorder=recorderRef.current||recorder;let currentContext=audioContextRef.current||audioContext;// Initialize recording if needed\nif(!currentRecorder||!currentContext){console.log('DEBUG: No recorder or context, initializing...');const initialized=await initRecording();if(!initialized){console.log('DEBUG: Failed to initialize recording');return false;}// Get updated refs after initialization\ncurrentRecorder=recorderRef.current;currentContext=audioContextRef.current;// Safety check\nif(!currentRecorder||!currentContext){console.error('DEBUG: Still no recorder or context after initialization');setError('Failed to initialize audio system correctly.');return false;}console.log('DEBUG: Successfully initialized recording components');}// Ensure audio context is running\nif(currentContext.state!=='running'){console.log(`DEBUG: Audio context not running (state: ${currentContext.state}), attempting to resume...`);const unlocked=await unlockAudioContext(currentContext);if(!unlocked){console.error('DEBUG: Context still not running after resume');setError('Could not activate audio system. Try clicking once anywhere on the page and try again.');return false;}}// Start recording\nconsole.log('DEBUG: Starting recorder...');try{await currentRecorder.start();console.log('DEBUG: Recording started successfully');setIsRecording(true);setAudioData(null);return true;}catch(startError){console.error('DEBUG: Error calling start():',startError);// Try to re-initialize on certain errors\nif(startError.name==='InvalidStateError'){// Recorder might be in a bad state - reinitialize\nconsole.log('DEBUG: Recorder in invalid state, attempting to reinitialize...');// Clean up existing resources\nif(currentRecorder){console.log('DEBUG: Cleaning up existing recorder');recorderRef.current=null;setRecorder(null);}// Try to initialize again\nconst reInitialized=await initRecording();if(reInitialized){console.log('DEBUG: Successfully reinitialized, trying to start again');await recorderRef.current.start();setIsRecording(true);setAudioData(null);return true;}}setError(`Recording failed to start: ${startError.message}`);return false;}}catch(err){console.error('DEBUG: General error in startRecording:',err);setError(`Could not start recording: ${err.message}`);return false;}},[recorder,audioContext,initRecording,unlockAudioContext]);// Stop recording and get the audio data\nconst stopRecording=useCallback(async()=>{const currentRecorder=recorderRef.current||recorder;if(!currentRecorder||!isRecording){console.log('DEBUG: No recorder available or not recording');return null;}try{console.log('DEBUG: Stopping recording...');const{blob,buffer}=await currentRecorder.stop();console.log('DEBUG: Recording stopped, got blob:',!!blob,'buffer:',!!buffer);// Add detailed debug info about the audio quality\nconsole.log('DEBUG: Audio blob size:',blob.size,'bytes');console.log('DEBUG: Audio duration:',currentRecorder.duration||'unknown','seconds');// Log potentially silent recordings\nif(blob.size<1000){console.warn('DEBUG: WARNING - Audio blob is very small, might be silent or corrupt');}// Analyze audio buffer amplitude if available\nif(buffer&&buffer.length>0&&buffer[0]&&buffer[0].length>0){const channel=buffer[0];let maxAmplitude=0;let sumAmplitude=0;// Sample the buffer to find max and average amplitude\nfor(let i=0;i<channel.length;i+=100){const amplitude=Math.abs(channel[i]||0);maxAmplitude=Math.max(maxAmplitude,amplitude);sumAmplitude+=amplitude;}const avgAmplitude=sumAmplitude/(channel.length/100);console.log('DEBUG: Audio max amplitude:',maxAmplitude,'avg amplitude:',avgAmplitude);if(maxAmplitude<0.01){console.warn('DEBUG: WARNING - Audio appears to be mostly silent (max amplitude < 0.01)');}}setIsRecording(false);setAudioData({blob,buffer});return{blob,buffer};}catch(err){console.error('DEBUG: Error stopping recording:',err);setError(`Error stopping recording: ${err.message}`);setIsRecording(false);// Force recording state to false\nreturn null;}},[recorder,isRecording]);// Convert audio blob to base64\nconst getAudioBase64=useCallback(async audioBlob=>{return new Promise((resolve,reject)=>{console.log('DEBUG: Converting audio blob to base64, size:',audioBlob.size);// Log audio blob type and create a URL for debugging\nconsole.log('DEBUG: Audio MIME type:',audioBlob.type);const blobUrl=URL.createObjectURL(audioBlob);console.log('DEBUG: Temporary blob URL (for debugging):',blobUrl);const reader=new FileReader();reader.onloadend=()=>{// Extract the base64 data from the result\n// The result is like \"data:audio/wav;base64,UklGRiXiAABXQVZF...\"\nconst base64Data=reader.result.split(',')[1];console.log('DEBUG: Converted blob to base64, length:',base64Data===null||base64Data===void 0?void 0:base64Data.length);// Add validation check for the base64 data\nif(!base64Data||base64Data.length<100){console.error('DEBUG: Generated base64 data is too small or missing');}// Log first and last few characters of base64\nif(base64Data){console.log('DEBUG: Base64 prefix:',base64Data.substring(0,50));console.log('DEBUG: Base64 suffix:',base64Data.substring(base64Data.length-50));}resolve(reader.result);// Return full data URI instead of just base64 part\n};reader.onerror=err=>{console.error('DEBUG: Error reading blob:',err);reject(err);};reader.readAsDataURL(audioBlob);});},[]);// Cancel recording\nconst cancelRecording=useCallback(()=>{const currentRecorder=recorderRef.current||recorder;if(currentRecorder&&isRecording){try{currentRecorder.cancel();console.log('DEBUG: Recording cancelled');}catch(err){console.error('DEBUG: Error cancelling recording:',err);}setIsRecording(false);}setAudioData(null);},[recorder,isRecording]);// Check permission status\nconst checkPermissionStatus=useCallback(async()=>{try{console.log('DEBUG: Checking microphone permission status...');// Try a permission query first if supported\nif(navigator.permissions&&navigator.permissions.query){try{const permissionStatus=await navigator.permissions.query({name:'microphone'});console.log('DEBUG: Permission status:',permissionStatus.state);if(permissionStatus.state==='granted'){return true;}else if(permissionStatus.state==='denied'){setError('Microphone access has been denied. Please update your browser settings.');return false;}// If 'prompt', we'll fall through to enumerate devices\n}catch(permErr){console.log('DEBUG: Permission query not supported:',permErr);// Fall through to enumerate devices\n}}// Enumerate devices as a fallback\nconst devices=await navigator.mediaDevices.enumerateDevices();const audioDevices=devices.filter(device=>device.kind==='audioinput');console.log('DEBUG: Found audio input devices:',audioDevices.length);if(audioDevices.length===0){setError('No audio input devices found.');return false;}// Check if any devices have labels (indicates permission was granted)\nconst hasLabels=audioDevices.some(device=>device.label&&device.label.length>0);console.log('DEBUG: Device labels available:',hasLabels);return true;}catch(err){console.error('DEBUG: Error checking permission status:',err);setError(`Error checking microphone access: ${err.message}`);return false;}},[]);// Reset the audio recorder (useful after errors)\nconst resetRecorder=useCallback(async()=>{console.log('DEBUG: Resetting audio recorder');// Stop any active tracks\nif(streamRef.current){streamRef.current.getTracks().forEach(track=>track.stop());streamRef.current=null;}// Close audio context\nif(audioContextRef.current){try{await audioContextRef.current.close();}catch(err){console.error('DEBUG: Error closing audio context:',err);}audioContextRef.current=null;}// Clear state\nrecorderRef.current=null;setStream(null);setRecorder(null);setAudioContext(null);setIsRecording(false);setError(null);return true;},[]);return{isRecording,audioData,error,permissionGranted,isInitializing,initRecording,startRecording,stopRecording,cancelRecording,getAudioBase64,checkPermissionStatus,resetRecorder,isMobileDevice:isMobile.current};};export default useAudioRecorder;","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","Recorder","useAudioRecorder","recorder","setRecorder","stream","setStream","isRecording","setIsRecording","audioData","setAudioData","error","setError","audioContext","setAudioContext","permissionGranted","setPermissionGranted","isInitializing","setIsInitializing","recorderRef","audioContextRef","streamRef","isMobile","test","navigator","userAgent","cleanupResources","console","log","current","getTracks","forEach","track","kind","stop","state","close","catch","err","unlockAudioContext","context","buffer","createBuffer","source","createBufferSource","connect","destination","start","setTimeout","resume","e","document","documentElement","addEventListener","unlock","then","removeEventListener","once","initRecording","audioStream","mediaDevices","getUserMedia","audio","echoCancellation","noiseSuppression","autoGainControl","AudioContext","window","webkitAudioContext","newRecorder","init","contextError","name","message","startRecording","currentRecorder","currentContext","initialized","unlocked","startError","reInitialized","stopRecording","blob","size","duration","warn","length","channel","maxAmplitude","sumAmplitude","i","amplitude","Math","abs","max","avgAmplitude","getAudioBase64","audioBlob","Promise","resolve","reject","type","blobUrl","URL","createObjectURL","reader","FileReader","onloadend","base64Data","result","split","substring","onerror","readAsDataURL","cancelRecording","cancel","checkPermissionStatus","permissions","query","permissionStatus","permErr","devices","enumerateDevices","audioDevices","filter","device","hasLabels","some","label","resetRecorder","isMobileDevice"],"sources":["/home/glitch/Documents/ai-interviewer/frontend/src/hooks/useAudioRecorder.js"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\nimport Recorder from 'recorder-js';\n\n/**\n * Custom hook for audio recording functionality\n * @returns {Object} Object containing recording state and functions\n */\nconst useAudioRecorder = () => {\n  const [recorder, setRecorder] = useState(null);\n  const [stream, setStream] = useState(null);\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioData, setAudioData] = useState(null);\n  const [error, setError] = useState(null);\n  const [audioContext, setAudioContext] = useState(null);\n  const [permissionGranted, setPermissionGranted] = useState(false);\n  const [isInitializing, setIsInitializing] = useState(false);\n  const recorderRef = useRef(null);\n  const audioContextRef = useRef(null);\n  const streamRef = useRef(null);\n\n  // Check if we're on a mobile device\n  const isMobile = useRef(/iPhone|iPad|iPod|Android/i.test(navigator.userAgent));\n\n  // Clean up audio resources when the component unmounts\n  useEffect(() => {\n    return () => {\n      // Clean up function\n      const cleanupResources = () => {\n        console.log(\"DEBUG: Cleaning up audio resources\");\n\n        // Stop all tracks in the stream if it exists\n        if (streamRef.current) {\n          streamRef.current.getTracks().forEach(track => {\n            console.log(`DEBUG: Stopping track: ${track.kind}`);\n            track.stop();\n          });\n          streamRef.current = null;\n        }\n        \n        // Close audio context if it exists\n        if (audioContextRef.current && audioContextRef.current.state !== 'closed') {\n          console.log(`DEBUG: Closing AudioContext (state: ${audioContextRef.current.state})`);\n          audioContextRef.current.close().catch(err => {\n            console.error(\"DEBUG: Error closing AudioContext:\", err);\n          });\n          audioContextRef.current = null;\n        }\n\n        // Release recorder resources if any\n        if (recorderRef.current) {\n          console.log(\"DEBUG: Cleaning up recorder\");\n          recorderRef.current = null;\n        }\n\n        // Clear state\n        setStream(null);\n        setRecorder(null);\n        setAudioContext(null);\n        setIsRecording(false);\n      };\n\n      try {\n        cleanupResources();\n      } catch (err) {\n        console.error(\"DEBUG: Error during cleanup:\", err);\n      }\n    };\n  }, []);\n\n  // Helper function to unlock audio context (especially on mobile)\n  const unlockAudioContext = useCallback(async (context) => {\n    console.log(`DEBUG: Attempting to unlock AudioContext (state: ${context.state})`);\n    \n    if (context.state === 'suspended') {\n      // Create and play a silent sound (crucial for iOS)\n      try {\n        const buffer = context.createBuffer(1, 1, 22050);\n        const source = context.createBufferSource();\n        source.buffer = buffer;\n        source.connect(context.destination);\n        source.start(0);\n        \n        // Try user interaction simulation for Safari/iOS\n        if (isMobile.current) {\n          console.log(\"DEBUG: Applying mobile-specific audio unlocking\");\n          \n          // Use both timeout and direct resume for better chances\n          setTimeout(() => {\n            context.resume().catch(e => console.log(\"DEBUG: Delayed resume failed:\", e));\n          }, 100);\n          \n          // Some browsers need direct user gesture to work\n          document.documentElement.addEventListener('touchend', function unlock() {\n            context.resume().then(() => {\n              document.documentElement.removeEventListener('touchend', unlock);\n              console.log(\"DEBUG: TouchEnd unlocked AudioContext\");\n            }).catch(e => console.log(\"DEBUG: TouchEnd resume failed:\", e));\n          }, { once: true });\n        }\n        \n        console.log(\"DEBUG: Direct resume attempt\");\n        await context.resume();\n        console.log(`DEBUG: AudioContext after unlock attempt: ${context.state}`);\n        return context.state === 'running';\n      } catch (err) {\n        console.error(\"DEBUG: Error unlocking audio context:\", err);\n        return false;\n      }\n    }\n    return context.state === 'running';\n  }, []);\n\n  // Initialize audio recording with clearer error handling\n  const initRecording = useCallback(async () => {\n    // Prevent multiple initializations\n    if (isInitializing) {\n      console.log('DEBUG: Already initializing audio...');\n      return false;\n    }\n\n    try {\n      setIsInitializing(true);\n      setError(null);\n      \n      console.log('DEBUG: Requesting microphone permission...');\n      \n      // Request user permission to access the microphone\n      const audioStream = await navigator.mediaDevices.getUserMedia({ \n        audio: {\n          echoCancellation: true,\n          noiseSuppression: true,\n          autoGainControl: true\n        } \n      });\n      \n      console.log('DEBUG: Microphone permission granted, got stream:', !!audioStream);\n      setStream(audioStream);\n      streamRef.current = audioStream;\n      setPermissionGranted(true);\n      \n      console.log('DEBUG: Creating audio context...');\n      \n      // Create an audio context\n      let context;\n      try {\n        // Safari requires prefix\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        context = new AudioContext();\n        console.log('DEBUG: Audio context created, state:', context.state);\n        \n        // Ensure the context is running\n        if (context.state !== 'running') {\n          console.log('DEBUG: Audio context not running, attempting to unlock...');\n          await unlockAudioContext(context);\n        }\n        \n        // Store the context references\n        setAudioContext(context);\n        audioContextRef.current = context;\n        \n        // Create a new recorder with the audio context\n        console.log('DEBUG: Creating recorder instance...');\n        const newRecorder = new Recorder(context);\n        \n        // Connect the recorder to the stream\n        console.log('DEBUG: Initializing recorder with stream...');\n        await newRecorder.init(audioStream);\n        console.log('DEBUG: Recorder initialized successfully');\n        \n        // Store the recorder references\n        setRecorder(newRecorder);\n        recorderRef.current = newRecorder;\n        \n        console.log('DEBUG: Audio recording setup complete');\n        return true;\n      } catch (contextError) {\n        console.error('DEBUG: Error with audio context:', contextError);\n        \n        // Try to release the stream since we failed\n        if (streamRef.current) {\n          streamRef.current.getTracks().forEach(track => track.stop());\n        }\n        \n        throw contextError;\n      }\n    } catch (err) {\n      console.error('DEBUG: Error initializing audio recording:', err.name, err.message);\n      \n      // Provide specific error messages based on the error type\n      if (err.name === 'NotAllowedError') {\n        setError('Microphone permission denied. Please allow access in your browser settings.');\n      } else if (err.name === 'NotFoundError') {\n        setError('No microphone detected. Please check your device settings.');\n      } else if (err.name === 'AbortError') {\n        setError('Recording permission request was aborted. Please try again.');\n      } else if (err.name === 'NotReadableError') {\n        setError('Microphone is already in use by another application.');\n      } else if (err.name === 'SecurityError') {\n        setError('Security error accessing microphone. Try using HTTPS.');\n      } else {\n        setError(`Error accessing microphone: ${err.message}`);\n      }\n      \n      return false;\n    } finally {\n      setIsInitializing(false);\n    }\n  }, [isInitializing, unlockAudioContext]);\n\n  // Start recording with improved error handling\n  const startRecording = useCallback(async () => {\n    try {\n      setError(null);\n      \n      // Using refs to avoid timing issues with state updates\n      let currentRecorder = recorderRef.current || recorder;\n      let currentContext = audioContextRef.current || audioContext;\n      \n      // Initialize recording if needed\n      if (!currentRecorder || !currentContext) {\n        console.log('DEBUG: No recorder or context, initializing...');\n        const initialized = await initRecording();\n        if (!initialized) {\n          console.log('DEBUG: Failed to initialize recording');\n          return false;\n        }\n        \n        // Get updated refs after initialization\n        currentRecorder = recorderRef.current;\n        currentContext = audioContextRef.current;\n        \n        // Safety check\n        if (!currentRecorder || !currentContext) {\n          console.error('DEBUG: Still no recorder or context after initialization');\n          setError('Failed to initialize audio system correctly.');\n          return false;\n        }\n        \n        console.log('DEBUG: Successfully initialized recording components');\n      }\n      \n      // Ensure audio context is running\n      if (currentContext.state !== 'running') {\n        console.log(`DEBUG: Audio context not running (state: ${currentContext.state}), attempting to resume...`);\n        \n        const unlocked = await unlockAudioContext(currentContext);\n        \n        if (!unlocked) {\n          console.error('DEBUG: Context still not running after resume');\n          setError('Could not activate audio system. Try clicking once anywhere on the page and try again.');\n          return false;\n        }\n      }\n      \n      // Start recording\n      console.log('DEBUG: Starting recorder...');\n      try {\n        await currentRecorder.start();\n        console.log('DEBUG: Recording started successfully');\n        setIsRecording(true);\n        setAudioData(null);\n        return true;\n      } catch (startError) {\n        console.error('DEBUG: Error calling start():', startError);\n        \n        // Try to re-initialize on certain errors\n        if (startError.name === 'InvalidStateError') {\n          // Recorder might be in a bad state - reinitialize\n          console.log('DEBUG: Recorder in invalid state, attempting to reinitialize...');\n          \n          // Clean up existing resources\n          if (currentRecorder) {\n            console.log('DEBUG: Cleaning up existing recorder');\n            recorderRef.current = null;\n            setRecorder(null);\n          }\n          \n          // Try to initialize again\n          const reInitialized = await initRecording();\n          if (reInitialized) {\n            console.log('DEBUG: Successfully reinitialized, trying to start again');\n            await recorderRef.current.start();\n            setIsRecording(true);\n            setAudioData(null);\n            return true;\n          }\n        }\n        \n        setError(`Recording failed to start: ${startError.message}`);\n        return false;\n      }\n    } catch (err) {\n      console.error('DEBUG: General error in startRecording:', err);\n      setError(`Could not start recording: ${err.message}`);\n      return false;\n    }\n  }, [recorder, audioContext, initRecording, unlockAudioContext]);\n\n  // Stop recording and get the audio data\n  const stopRecording = useCallback(async () => {\n    const currentRecorder = recorderRef.current || recorder;\n    \n    if (!currentRecorder || !isRecording) {\n      console.log('DEBUG: No recorder available or not recording');\n      return null;\n    }\n\n    try {\n      console.log('DEBUG: Stopping recording...');\n      const { blob, buffer } = await currentRecorder.stop();\n      console.log('DEBUG: Recording stopped, got blob:', !!blob, 'buffer:', !!buffer);\n      \n      // Add detailed debug info about the audio quality\n      console.log('DEBUG: Audio blob size:', blob.size, 'bytes');\n      console.log('DEBUG: Audio duration:', currentRecorder.duration || 'unknown', 'seconds');\n      \n      // Log potentially silent recordings\n      if (blob.size < 1000) {\n        console.warn('DEBUG: WARNING - Audio blob is very small, might be silent or corrupt');\n      }\n      \n      // Analyze audio buffer amplitude if available\n      if (buffer && buffer.length > 0 && buffer[0] && buffer[0].length > 0) {\n        const channel = buffer[0];\n        let maxAmplitude = 0;\n        let sumAmplitude = 0;\n        \n        // Sample the buffer to find max and average amplitude\n        for (let i = 0; i < channel.length; i += 100) {\n          const amplitude = Math.abs(channel[i] || 0);\n          maxAmplitude = Math.max(maxAmplitude, amplitude);\n          sumAmplitude += amplitude;\n        }\n        \n        const avgAmplitude = sumAmplitude / (channel.length / 100);\n        console.log('DEBUG: Audio max amplitude:', maxAmplitude, 'avg amplitude:', avgAmplitude);\n        \n        if (maxAmplitude < 0.01) {\n          console.warn('DEBUG: WARNING - Audio appears to be mostly silent (max amplitude < 0.01)');\n        }\n      }\n      \n      setIsRecording(false);\n      setAudioData({ blob, buffer });\n      return { blob, buffer };\n    } catch (err) {\n      console.error('DEBUG: Error stopping recording:', err);\n      setError(`Error stopping recording: ${err.message}`);\n      setIsRecording(false); // Force recording state to false\n      return null;\n    }\n  }, [recorder, isRecording]);\n\n  // Convert audio blob to base64\n  const getAudioBase64 = useCallback(async (audioBlob) => {\n    return new Promise((resolve, reject) => {\n      console.log('DEBUG: Converting audio blob to base64, size:', audioBlob.size);\n      \n      // Log audio blob type and create a URL for debugging\n      console.log('DEBUG: Audio MIME type:', audioBlob.type);\n      const blobUrl = URL.createObjectURL(audioBlob);\n      console.log('DEBUG: Temporary blob URL (for debugging):', blobUrl);\n      \n      const reader = new FileReader();\n      reader.onloadend = () => {\n        // Extract the base64 data from the result\n        // The result is like \"data:audio/wav;base64,UklGRiXiAABXQVZF...\"\n        const base64Data = reader.result.split(',')[1];\n        console.log('DEBUG: Converted blob to base64, length:', base64Data?.length);\n        \n        // Add validation check for the base64 data\n        if (!base64Data || base64Data.length < 100) {\n          console.error('DEBUG: Generated base64 data is too small or missing');\n        }\n        \n        // Log first and last few characters of base64\n        if (base64Data) {\n          console.log('DEBUG: Base64 prefix:', base64Data.substring(0, 50));\n          console.log('DEBUG: Base64 suffix:', base64Data.substring(base64Data.length - 50));\n        }\n        \n        resolve(reader.result); // Return full data URI instead of just base64 part\n      };\n      reader.onerror = (err) => {\n        console.error('DEBUG: Error reading blob:', err);\n        reject(err);\n      };\n      reader.readAsDataURL(audioBlob);\n    });\n  }, []);\n\n  // Cancel recording\n  const cancelRecording = useCallback(() => {\n    const currentRecorder = recorderRef.current || recorder;\n    if (currentRecorder && isRecording) {\n      try {\n        currentRecorder.cancel();\n        console.log('DEBUG: Recording cancelled');\n      } catch (err) {\n        console.error('DEBUG: Error cancelling recording:', err);\n      }\n      setIsRecording(false);\n    }\n    setAudioData(null);\n  }, [recorder, isRecording]);\n  \n  // Check permission status\n  const checkPermissionStatus = useCallback(async () => {\n    try {\n      console.log('DEBUG: Checking microphone permission status...');\n      // Try a permission query first if supported\n      if (navigator.permissions && navigator.permissions.query) {\n        try {\n          const permissionStatus = await navigator.permissions.query({ name: 'microphone' });\n          console.log('DEBUG: Permission status:', permissionStatus.state);\n          \n          if (permissionStatus.state === 'granted') {\n            return true;\n          } else if (permissionStatus.state === 'denied') {\n            setError('Microphone access has been denied. Please update your browser settings.');\n            return false;\n          }\n          // If 'prompt', we'll fall through to enumerate devices\n        } catch (permErr) {\n          console.log('DEBUG: Permission query not supported:', permErr);\n          // Fall through to enumerate devices\n        }\n      }\n      \n      // Enumerate devices as a fallback\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      const audioDevices = devices.filter(device => device.kind === 'audioinput');\n      \n      console.log('DEBUG: Found audio input devices:', audioDevices.length);\n      \n      if (audioDevices.length === 0) {\n        setError('No audio input devices found.');\n        return false;\n      }\n      \n      // Check if any devices have labels (indicates permission was granted)\n      const hasLabels = audioDevices.some(device => device.label && device.label.length > 0);\n      console.log('DEBUG: Device labels available:', hasLabels);\n      \n      return true;\n    } catch (err) {\n      console.error('DEBUG: Error checking permission status:', err);\n      setError(`Error checking microphone access: ${err.message}`);\n      return false;\n    }\n  }, []);\n\n  // Reset the audio recorder (useful after errors)\n  const resetRecorder = useCallback(async () => {\n    console.log('DEBUG: Resetting audio recorder');\n    \n    // Stop any active tracks\n    if (streamRef.current) {\n      streamRef.current.getTracks().forEach(track => track.stop());\n      streamRef.current = null;\n    }\n    \n    // Close audio context\n    if (audioContextRef.current) {\n      try {\n        await audioContextRef.current.close();\n      } catch (err) {\n        console.error('DEBUG: Error closing audio context:', err);\n      }\n      audioContextRef.current = null;\n    }\n    \n    // Clear state\n    recorderRef.current = null;\n    setStream(null);\n    setRecorder(null);\n    setAudioContext(null);\n    setIsRecording(false);\n    setError(null);\n    \n    return true;\n  }, []);\n\n  return {\n    isRecording,\n    audioData,\n    error,\n    permissionGranted,\n    isInitializing,\n    initRecording,\n    startRecording,\n    stopRecording,\n    cancelRecording,\n    getAudioBase64,\n    checkPermissionStatus,\n    resetRecorder,\n    isMobileDevice: isMobile.current\n  };\n};\n\nexport default useAudioRecorder; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}