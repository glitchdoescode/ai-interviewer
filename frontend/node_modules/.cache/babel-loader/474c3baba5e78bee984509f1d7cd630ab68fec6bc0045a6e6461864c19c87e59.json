{"ast":null,"code":"import{useState,useEffect,useCallback}from'react';import Recorder from'recorder-js';/**\n * Custom hook for audio recording functionality\n * @returns {Object} Object containing recording state and functions\n */const useAudioRecorder=()=>{const[recorder,setRecorder]=useState(null);const[stream,setStream]=useState(null);const[isRecording,setIsRecording]=useState(false);const[audioData,setAudioData]=useState(null);const[error,setError]=useState(null);const[audioContext,setAudioContext]=useState(null);// Clean up audio resources when the component unmounts\nuseEffect(()=>{return()=>{if(stream){// Stop all audio tracks\nstream.getTracks().forEach(track=>track.stop());}// Close audio context if it exists\nif(audioContext&&audioContext.state!=='closed'){audioContext.close();}};},[stream,audioContext]);// Initialize audio recording\nconst initRecording=useCallback(async()=>{try{setError(null);// Request user permission to access the microphone\nconst audioStream=await navigator.mediaDevices.getUserMedia({audio:true});setStream(audioStream);// Create an audio context\nlet context;try{context=new(window.AudioContext||window.webkitAudioContext)();setAudioContext(context);}catch(contextError){console.error('Error creating AudioContext:',contextError);throw new Error(`Could not create audio context: ${contextError.message}`);}// Create a new recorder with the audio context\nconst newRecorder=new Recorder(context,{onAnalysed:data=>{// You can use this callback to visualize the audio data\n// console.log('Audio data:', data);\n}});// Connect the recorder to the stream\nawait newRecorder.init(audioStream);// Save the recorder in state\nsetRecorder(newRecorder);return true;}catch(err){console.error('Error initializing audio recording:',err);setError(`Error accessing microphone: ${err.message}`);return false;}},[]);// Start recording\nconst startRecording=useCallback(async()=>{try{// Reset any previous errors\nsetError(null);// If recorder doesn't exist, initialize it first\nif(!recorder){const initialized=await initRecording();if(!initialized){return false;}// Return a new promise that will resolve after the recorder is initialized\nreturn new Promise(resolve=>{// Need to delay until next render cycle when recorder state is updated\nsetTimeout(()=>{try{// Instead of relying on the state, we'll check for the AudioContext status\nif(!audioContext||audioContext.state!=='running'){throw new Error('AudioContext not ready or running');}// Instead of directly using recorder state which might not be updated yet,\n// we'll get a fresh reference through the AudioContext\nconst audioCtx=audioContext;// Verify audio context is active by creating a test node and checking its state\nif(!audioCtx||audioCtx.state!=='running'){throw new Error('AudioContext not active');}if(!stream){throw new Error('Audio stream not available');}// Try to resume the AudioContext if it's suspended\nif(audioCtx.state==='suspended'){audioCtx.resume();}// Manually trigger recorder init again to ensure it's connected\nconst newRecorder=new Recorder(audioCtx);newRecorder.init(stream);setRecorder(newRecorder);// Start recording with the new recorder\nnewRecorder.start();setIsRecording(true);setAudioData(null);resolve(true);}catch(startErr){console.error('Error starting recorder after init:',startErr);setError(`Error starting recording: ${startErr.message}`);resolve(false);}},300);// Increased delay to ensure state updates have completed\n});}// If recorder already exists, use it directly\nif(recorder){try{// Make sure AudioContext is running\nif(audioContext&&audioContext.state==='suspended'){await audioContext.resume();}recorder.start();setIsRecording(true);setAudioData(null);return true;}catch(err){console.error('Error starting existing recorder:',err);setError(`Error starting recording: ${err.message}`);// If starting fails with existing recorder, try to create a new one\nsetRecorder(null);return startRecording();// Recursive call will go through the initialization path\n}}return false;}catch(err){console.error('Error in startRecording:',err);setError(`Error starting recording: ${err.message}`);return false;}},[recorder,initRecording,stream,audioContext]);// Stop recording and get the audio data\nconst stopRecording=useCallback(async()=>{if(!recorder||!isRecording)return null;try{const{blob,buffer}=await recorder.stop();setIsRecording(false);setAudioData({blob,buffer});return{blob,buffer};}catch(err){console.error('Error stopping recording:',err);setError(`Error stopping recording: ${err.message}`);return null;}},[recorder,isRecording]);// Convert audio blob to base64\nconst getAudioBase64=useCallback(async audioBlob=>{return new Promise((resolve,reject)=>{const reader=new FileReader();reader.onloadend=()=>{// Extract the base64 data from the result\n// The result is like \"data:audio/wav;base64,UklGRiXiAABXQVZF...\"\nconst base64Data=reader.result.split(',')[1];resolve(base64Data);};reader.onerror=reject;reader.readAsDataURL(audioBlob);});},[]);// Cancel recording\nconst cancelRecording=useCallback(()=>{if(recorder&&isRecording){recorder.cancel();setIsRecording(false);}setAudioData(null);},[recorder,isRecording]);return{isRecording,audioData,error,initRecording,startRecording,stopRecording,cancelRecording,getAudioBase64};};export default useAudioRecorder;","map":{"version":3,"names":["useState","useEffect","useCallback","Recorder","useAudioRecorder","recorder","setRecorder","stream","setStream","isRecording","setIsRecording","audioData","setAudioData","error","setError","audioContext","setAudioContext","getTracks","forEach","track","stop","state","close","initRecording","audioStream","navigator","mediaDevices","getUserMedia","audio","context","window","AudioContext","webkitAudioContext","contextError","console","Error","message","newRecorder","onAnalysed","data","init","err","startRecording","initialized","Promise","resolve","setTimeout","audioCtx","resume","start","startErr","stopRecording","blob","buffer","getAudioBase64","audioBlob","reject","reader","FileReader","onloadend","base64Data","result","split","onerror","readAsDataURL","cancelRecording","cancel"],"sources":["/home/glitch/Documents/ai-interviewer/frontend/src/hooks/useAudioRecorder.js"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\nimport Recorder from 'recorder-js';\n\n/**\n * Custom hook for audio recording functionality\n * @returns {Object} Object containing recording state and functions\n */\nconst useAudioRecorder = () => {\n  const [recorder, setRecorder] = useState(null);\n  const [stream, setStream] = useState(null);\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioData, setAudioData] = useState(null);\n  const [error, setError] = useState(null);\n  const [audioContext, setAudioContext] = useState(null);\n\n  // Clean up audio resources when the component unmounts\n  useEffect(() => {\n    return () => {\n      if (stream) {\n        // Stop all audio tracks\n        stream.getTracks().forEach(track => track.stop());\n      }\n      \n      // Close audio context if it exists\n      if (audioContext && audioContext.state !== 'closed') {\n        audioContext.close();\n      }\n    };\n  }, [stream, audioContext]);\n\n  // Initialize audio recording\n  const initRecording = useCallback(async () => {\n    try {\n      setError(null);\n      \n      // Request user permission to access the microphone\n      const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      setStream(audioStream);\n      \n      // Create an audio context\n      let context;\n      try {\n        context = new (window.AudioContext || window.webkitAudioContext)();\n        setAudioContext(context);\n      } catch (contextError) {\n        console.error('Error creating AudioContext:', contextError);\n        throw new Error(`Could not create audio context: ${contextError.message}`);\n      }\n      \n      // Create a new recorder with the audio context\n      const newRecorder = new Recorder(context, {\n        onAnalysed: data => {\n          // You can use this callback to visualize the audio data\n          // console.log('Audio data:', data);\n        },\n      });\n\n      // Connect the recorder to the stream\n      await newRecorder.init(audioStream);\n      \n      // Save the recorder in state\n      setRecorder(newRecorder);\n      return true;\n    } catch (err) {\n      console.error('Error initializing audio recording:', err);\n      setError(`Error accessing microphone: ${err.message}`);\n      return false;\n    }\n  }, []);\n\n  // Start recording\n  const startRecording = useCallback(async () => {\n    try {\n      // Reset any previous errors\n      setError(null);\n      \n      // If recorder doesn't exist, initialize it first\n      if (!recorder) {\n        const initialized = await initRecording();\n        if (!initialized) {\n          return false;\n        }\n        \n        // Return a new promise that will resolve after the recorder is initialized\n        return new Promise(resolve => {\n          // Need to delay until next render cycle when recorder state is updated\n          setTimeout(() => {\n            try {\n              // Instead of relying on the state, we'll check for the AudioContext status\n              if (!audioContext || audioContext.state !== 'running') {\n                throw new Error('AudioContext not ready or running');\n              }\n              \n              // Instead of directly using recorder state which might not be updated yet,\n              // we'll get a fresh reference through the AudioContext\n              const audioCtx = audioContext;\n              \n              // Verify audio context is active by creating a test node and checking its state\n              if (!audioCtx || audioCtx.state !== 'running') {\n                throw new Error('AudioContext not active');\n              }\n              \n              if (!stream) {\n                throw new Error('Audio stream not available');\n              }\n              \n              // Try to resume the AudioContext if it's suspended\n              if (audioCtx.state === 'suspended') {\n                audioCtx.resume();\n              }\n              \n              // Manually trigger recorder init again to ensure it's connected\n              const newRecorder = new Recorder(audioCtx);\n              newRecorder.init(stream);\n              setRecorder(newRecorder);\n              \n              // Start recording with the new recorder\n              newRecorder.start();\n              setIsRecording(true);\n              setAudioData(null);\n              resolve(true);\n            } catch (startErr) {\n              console.error('Error starting recorder after init:', startErr);\n              setError(`Error starting recording: ${startErr.message}`);\n              resolve(false);\n            }\n          }, 300); // Increased delay to ensure state updates have completed\n        });\n      }\n      \n      // If recorder already exists, use it directly\n      if (recorder) {\n        try {\n          // Make sure AudioContext is running\n          if (audioContext && audioContext.state === 'suspended') {\n            await audioContext.resume();\n          }\n          \n          recorder.start();\n          setIsRecording(true);\n          setAudioData(null);\n          return true;\n        } catch (err) {\n          console.error('Error starting existing recorder:', err);\n          setError(`Error starting recording: ${err.message}`);\n          \n          // If starting fails with existing recorder, try to create a new one\n          setRecorder(null);\n          return startRecording(); // Recursive call will go through the initialization path\n        }\n      }\n      \n      return false;\n    } catch (err) {\n      console.error('Error in startRecording:', err);\n      setError(`Error starting recording: ${err.message}`);\n      return false;\n    }\n  }, [recorder, initRecording, stream, audioContext]);\n\n  // Stop recording and get the audio data\n  const stopRecording = useCallback(async () => {\n    if (!recorder || !isRecording) return null;\n\n    try {\n      const { blob, buffer } = await recorder.stop();\n      setIsRecording(false);\n      setAudioData({ blob, buffer });\n      return { blob, buffer };\n    } catch (err) {\n      console.error('Error stopping recording:', err);\n      setError(`Error stopping recording: ${err.message}`);\n      return null;\n    }\n  }, [recorder, isRecording]);\n\n  // Convert audio blob to base64\n  const getAudioBase64 = useCallback(async (audioBlob) => {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onloadend = () => {\n        // Extract the base64 data from the result\n        // The result is like \"data:audio/wav;base64,UklGRiXiAABXQVZF...\"\n        const base64Data = reader.result.split(',')[1];\n        resolve(base64Data);\n      };\n      reader.onerror = reject;\n      reader.readAsDataURL(audioBlob);\n    });\n  }, []);\n\n  // Cancel recording\n  const cancelRecording = useCallback(() => {\n    if (recorder && isRecording) {\n      recorder.cancel();\n      setIsRecording(false);\n    }\n    setAudioData(null);\n  }, [recorder, isRecording]);\n\n  return {\n    isRecording,\n    audioData,\n    error,\n    initRecording,\n    startRecording,\n    stopRecording,\n    cancelRecording,\n    getAudioBase64,\n  };\n};\n\nexport default useAudioRecorder; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}