{"ast":null,"code":"import axios from'axios';// Base URL for API requests\nconst API_URL='/api';// Create axios instance with default config\nconst api=axios.create({baseURL:API_URL,headers:{'Content-Type':'application/json'},// Add timeout to prevent hanging requests\ntimeout:30000// 30 seconds\n});// Global error handler function\nconst handleApiError=function(error){var _error$response,_error$response2;let customMessage=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;// Extract the most useful error information\nlet errorMessage=customMessage||'An error occurred';if(error.response){var _error$response$data;// The server responded with an error status code\nconst serverError=((_error$response$data=error.response.data)===null||_error$response$data===void 0?void 0:_error$response$data.detail)||error.response.statusText;errorMessage=`Server error: ${serverError}`;console.error('API error response:',{status:error.response.status,data:error.response.data,message:serverError});}else if(error.request){// The request was made but no response was received\nerrorMessage='No response from server. Check your network connection.';console.error('API no response:',error.request);}else{// Something else caused the error\nerrorMessage=error.message||errorMessage;console.error('API request error:',error.message);}// Create an enhanced error object\nconst enhancedError=new Error(errorMessage);enhancedError.originalError=error;enhancedError.status=(_error$response=error.response)===null||_error$response===void 0?void 0:_error$response.status;enhancedError.serverData=(_error$response2=error.response)===null||_error$response2===void 0?void 0:_error$response2.data;throw enhancedError;};/**\n * Start a new interview session\n * @param {string} message - Initial user message\n * @param {string} userId - Optional user ID\n * @param {Object} jobRoleData - Optional job role configuration\n * @returns {Promise} Promise with response data\n */export const startInterview=async function(message){let userId=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;let jobRoleData=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;try{const requestBody={message,user_id:userId};// Add job role data if provided\nif(jobRoleData){requestBody.job_role=jobRoleData.role_name;requestBody.seniority_level=jobRoleData.seniority_level;requestBody.required_skills=jobRoleData.required_skills;requestBody.job_description=jobRoleData.description;}const response=await api.post('/interview',requestBody);return response.data;}catch(error){return handleApiError(error,'Failed to start interview');}};/**\n * Continue an existing interview session\n * @param {string} message - User message\n * @param {string} sessionId - Interview session ID\n * @param {string} userId - User ID\n * @param {Object} jobRoleData - Optional job role configuration for new sessions\n * @returns {Promise} Promise with response data\n */export const continueInterview=async function(message,sessionId,userId){let jobRoleData=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;try{if(!sessionId){throw new Error('Session ID is required');}if(!userId){throw new Error('User ID is required');}const requestBody={message,user_id:userId};// Add job role data if provided\nif(jobRoleData){requestBody.job_role=jobRoleData.role_name;requestBody.seniority_level=jobRoleData.seniority_level;requestBody.required_skills=jobRoleData.required_skills;requestBody.job_description=jobRoleData.description;}const response=await api.post(`/interview/${sessionId}`,requestBody);return response.data;}catch(error){return handleApiError(error,'Failed to continue interview');}};/**\n * Get all sessions for a user\n * @param {string} userId - User ID\n * @param {boolean} includeCompleted - Whether to include completed sessions\n * @returns {Promise} Promise with response data\n */export const getUserSessions=async function(userId){let includeCompleted=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;try{if(!userId){throw new Error('User ID is required');}const response=await api.get(`/sessions/${userId}`,{params:{include_completed:includeCompleted}});return response.data;}catch(error){return handleApiError(error,'Failed to retrieve user sessions');}};/**\n * Transcribe audio and get a response\n * @param {string} audioBase64 - Base64-encoded audio data\n * @param {string} userId - User ID\n * @param {string} sessionId - Optional session ID\n * @param {Object} jobRoleData - Optional job role configuration\n * @returns {Promise} Promise with response data\n */export const transcribeAndRespond=async function(audioBase64,userId){let sessionId=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;let jobRoleData=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;try{if(!audioBase64){console.error('DEBUG: Audio data is missing or empty');throw new Error('Audio data is required');}// Enhanced debugging for audio data\nconst isFullDataUri=audioBase64.startsWith('data:audio/');const dataLength=audioBase64.length;console.log('DEBUG: Audio data stats:',{totalLength:dataLength,isDataUri:isFullDataUri,prefix:audioBase64.substring(0,30)+'...',suffix:'...'+audioBase64.substring(audioBase64.length-30)});// Validate audio data format\nif(!isFullDataUri&&!audioBase64.match(/^[A-Za-z0-9+/=]+$/)){console.warn('DEBUG: Audio data does not appear to be valid base64 or data URI');}// Ensure we use the full data URI for the backend\nlet formattedAudioData=audioBase64;if(!isFullDataUri){// If we just got the base64 part, add the data URI prefix\nconsole.log('DEBUG: Adding data URI prefix to raw base64 data');formattedAudioData=`data:audio/wav;base64,${audioBase64}`;}const requestBody={audio_data:formattedAudioData,user_id:userId||`anon-${Date.now()}`,session_id:sessionId,sample_rate:16000,// Default sample rate\nchannels:1// Default channels\n};// Log request size for debugging\nconsole.log(`DEBUG: Sending transcription request with ${Math.round(formattedAudioData.length/1024)}KB audio data`);// Add job role data if provided\nif(jobRoleData){requestBody.job_role=jobRoleData.role_name;requestBody.seniority_level=jobRoleData.seniority_level;requestBody.required_skills=jobRoleData.required_skills;requestBody.job_description=jobRoleData.description;}console.log('DEBUG: Sending audio transcription request...');// Create a custom config for the axios request with longer timeout\nconst requestConfig={timeout:60000,// 60 seconds for audio processing\nheaders:{'Content-Type':'application/json'}};try{const response=await api.post('/audio/transcribe',requestBody,requestConfig);// Validate response\nif(!response.data||!response.data.transcription){console.error('DEBUG: Invalid response structure:',response.data);throw new Error('Invalid response from transcription service');}console.log('DEBUG: Transcription successful:',response.data.transcription);return response.data;}catch(requestError){console.error('DEBUG: Transcription request failed:',requestError);// Capture response data if available\nif(requestError.response){console.error('DEBUG: Server response:',{status:requestError.response.status,data:requestError.response.data});}throw requestError;}}catch(error){// Special handling for 501 Not Implemented - voice processing not available\nif(error.response&&error.response.status===501){console.error('DEBUG: Voice processing not available (501)');const enhancedError=new Error('Voice processing is not available on this server');enhancedError.isVoiceUnavailable=true;throw enhancedError;}// Special handling for 422 Unprocessable Entity - no speech detected\nif(error.response&&error.response.status===422){console.error('DEBUG: No speech detected or transcription failed (422)');const enhancedError=new Error('No speech detected or audio could not be transcribed');enhancedError.isNoSpeech=true;throw enhancedError;}return handleApiError(error,'Failed to process voice input');}};/**\n * Check if voice processing is available on the server\n * @returns {Promise<boolean>} Promise resolving to true if voice processing is available, false otherwise\n */export const checkVoiceAvailability=async()=>{try{const response=await api.get('/health');return response.data.voice_processing==='available';}catch(error){console.error('Error checking voice availability:',error);return false;}};/**\n * Submit code for a coding challenge\n * @param {string} challengeId - Challenge ID\n * @param {string} code - Candidate's code\n * @param {string} userId - User ID\n * @param {string} sessionId - Session ID\n * @returns {Promise} Promise with evaluation results\n */export const submitChallengeCode=async function(challengeId,code){let userId=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;let sessionId=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;try{if(!challengeId){throw new Error('Challenge ID is required');}if(!code||code.trim()===''){throw new Error('Code solution is required');}const requestBody={challenge_id:challengeId,code:code,user_id:userId,session_id:sessionId};const response=await api.post('/coding/submit',requestBody);return response.data;}catch(error){return handleApiError(error,'Failed to submit code solution');}};/**\n * Get a hint for the current coding challenge\n * @param {string} challengeId - Challenge ID\n * @param {string} code - Current code implementation\n * @param {string} userId - User ID\n * @param {string} sessionId - Session ID\n * @param {string} errorMessage - Optional error message to get specific help\n * @returns {Promise} Promise with hints\n */export const getChallengeHint=async function(challengeId,code){let userId=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;let sessionId=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;let errorMessage=arguments.length>4&&arguments[4]!==undefined?arguments[4]:null;try{if(!challengeId){throw new Error('Challenge ID is required');}const requestBody={challenge_id:challengeId,code:code||'',user_id:userId,session_id:sessionId,error_message:errorMessage};const response=await api.post('/coding/hint',requestBody);return response.data;}catch(error){return handleApiError(error,'Failed to get hint');}};/**\n * Continue after completing a coding challenge\n * @param {string} message - User message (typically about the completed challenge)\n * @param {string} sessionId - Session ID\n * @param {string} userId - User ID\n * @param {boolean} completed - Whether the challenge was completed successfully\n * @returns {Promise} Promise with response data\n */export const continueAfterCodingChallenge=async function(message,sessionId,userId){let completed=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;try{if(!sessionId){throw new Error('Session ID is required');}if(!userId){throw new Error('User ID is required');}const requestBody={message,user_id:userId,challenge_completed:completed};const response=await api.post(`/interview/${sessionId}/challenge-complete`,requestBody);return response.data;}catch(error){return handleApiError(error,'Failed to continue after challenge');}};/**\n * Fetches available job roles for interviews\n * @returns {Promise<Array>} Array of job role objects\n */export const getJobRoles=async()=>{try{const response=await api.get('/job-roles');return response.data;}catch(error){return handleApiError(error,'Failed to fetch job roles');}};/**\n * Test audio transcription with a synthetic test tone\n * This function creates a test audio file with a clear beep sound and attempts to transcribe it\n * Useful for debugging if the transcription service is working properly\n * @returns {Promise} Promise with test results\n */export const testAudioTranscription=async()=>{console.log('DEBUG: Starting audio transcription test');try{// Create a test audio context\nconst audioContext=new(window.AudioContext||window.webkitAudioContext)();const oscillator=audioContext.createOscillator();const gainNode=audioContext.createGain();const destination=audioContext.createMediaStreamDestination();// Set up a clear beep tone\noscillator.type='sine';oscillator.frequency.setValueAtTime(440,audioContext.currentTime);// A4 note\ngainNode.gain.setValueAtTime(0.8,audioContext.currentTime);// Loud enough to hear\n// Connect the nodes\noscillator.connect(gainNode);gainNode.connect(destination);// Start the oscillator\noscillator.start();console.log('DEBUG: Created test tone generator');// Create a media recorder\nconst mediaRecorder=new MediaRecorder(destination.stream,{mimeType:'audio/webm',audioBitsPerSecond:128000});const chunks=[];mediaRecorder.ondataavailable=e=>{console.log('DEBUG: Test audio chunk received, size:',e.data.size);chunks.push(e.data);};// Record for 3 seconds\nconsole.log('DEBUG: Recording test audio for 3 seconds');await new Promise(resolve=>{mediaRecorder.onstop=resolve;mediaRecorder.start();// Generate a sequence of tones for better recognition\nsetTimeout(()=>oscillator.frequency.setValueAtTime(523.25,audioContext.currentTime),1000);// C5\nsetTimeout(()=>oscillator.frequency.setValueAtTime(659.25,audioContext.currentTime),2000);// E5\nsetTimeout(()=>{oscillator.stop();mediaRecorder.stop();console.log('DEBUG: Test audio recording completed');},3000);});// Create a blob from the chunks\nconst blob=new Blob(chunks,{type:'audio/webm'});console.log('DEBUG: Test audio blob created, size:',blob.size,'bytes');// Convert the blob to base64\nconst base64=await new Promise((resolve,reject)=>{const reader=new FileReader();reader.onloadend=()=>resolve(reader.result);reader.onerror=reject;reader.readAsDataURL(blob);});console.log('DEBUG: Test audio converted to base64, length:',base64.length);// Create a temporary audio element for debugging\nconst audio=new Audio(URL.createObjectURL(blob));console.log('DEBUG: Test audio available at temporary URL:',audio.src);// Try to transcribe the test audio\nconsole.log('DEBUG: Sending test audio for transcription');const userId='test-user-'+Date.now();try{const result=await transcribeAndRespond(base64,userId);console.log('DEBUG: Test transcription successful!',result);return{success:true,transcription:result.transcription,audioSize:blob.size,base64Length:base64.length};}catch(transcribeError){console.error('DEBUG: Test transcription failed',transcribeError);return{success:false,error:transcribeError.message,errorData:transcribeError.serverData,audioSize:blob.size,base64Length:base64.length};}finally{// Clean up\naudioContext.close();}}catch(error){console.error('DEBUG: Error creating test audio:',error);return{success:false,error:error.message,stage:'audio_creation'};}};// Set up a response interceptor for global error handling\napi.interceptors.response.use(response=>response,error=>{// Handle rate limiting errors (429)\nif(error.response&&error.response.status===429){console.error('Rate limit exceeded:',error.response.data);error.message='Too many requests. Please wait a moment before trying again.';}// Handle server errors (500)\nif(error.response&&error.response.status>=500){console.error('Server error:',error.response.data);error.message='The server encountered an error. Please try again later.';}return Promise.reject(error);});// Create a service object to export\nconst interviewService={startInterview,continueInterview,getUserSessions,transcribeAndRespond,checkVoiceAvailability,submitChallengeCode,getChallengeHint,continueAfterCodingChallenge,getJobRoles,testAudioTranscription};export default interviewService;","map":{"version":3,"names":["axios","API_URL","api","create","baseURL","headers","timeout","handleApiError","error","_error$response","_error$response2","customMessage","arguments","length","undefined","errorMessage","response","_error$response$data","serverError","data","detail","statusText","console","status","message","request","enhancedError","Error","originalError","serverData","startInterview","userId","jobRoleData","requestBody","user_id","job_role","role_name","seniority_level","required_skills","job_description","description","post","continueInterview","sessionId","getUserSessions","includeCompleted","get","params","include_completed","transcribeAndRespond","audioBase64","isFullDataUri","startsWith","dataLength","log","totalLength","isDataUri","prefix","substring","suffix","match","warn","formattedAudioData","audio_data","Date","now","session_id","sample_rate","channels","Math","round","requestConfig","transcription","requestError","isVoiceUnavailable","isNoSpeech","checkVoiceAvailability","voice_processing","submitChallengeCode","challengeId","code","trim","challenge_id","getChallengeHint","error_message","continueAfterCodingChallenge","completed","challenge_completed","getJobRoles","testAudioTranscription","audioContext","window","AudioContext","webkitAudioContext","oscillator","createOscillator","gainNode","createGain","destination","createMediaStreamDestination","type","frequency","setValueAtTime","currentTime","gain","connect","start","mediaRecorder","MediaRecorder","stream","mimeType","audioBitsPerSecond","chunks","ondataavailable","e","size","push","Promise","resolve","onstop","setTimeout","stop","blob","Blob","base64","reject","reader","FileReader","onloadend","result","onerror","readAsDataURL","audio","Audio","URL","createObjectURL","src","success","audioSize","base64Length","transcribeError","errorData","close","stage","interceptors","use","interviewService"],"sources":["/home/glitch/Documents/ai-interviewer/frontend/src/api/interviewService.js"],"sourcesContent":["import axios from 'axios';\n\n// Base URL for API requests\nconst API_URL = '/api';\n\n// Create axios instance with default config\nconst api = axios.create({\n  baseURL: API_URL,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  // Add timeout to prevent hanging requests\n  timeout: 30000, // 30 seconds\n});\n\n// Global error handler function\nconst handleApiError = (error, customMessage = null) => {\n  // Extract the most useful error information\n  let errorMessage = customMessage || 'An error occurred';\n  \n  if (error.response) {\n    // The server responded with an error status code\n    const serverError = error.response.data?.detail || error.response.statusText;\n    errorMessage = `Server error: ${serverError}`;\n    console.error('API error response:', {\n      status: error.response.status,\n      data: error.response.data,\n      message: serverError\n    });\n  } else if (error.request) {\n    // The request was made but no response was received\n    errorMessage = 'No response from server. Check your network connection.';\n    console.error('API no response:', error.request);\n  } else {\n    // Something else caused the error\n    errorMessage = error.message || errorMessage;\n    console.error('API request error:', error.message);\n  }\n  \n  // Create an enhanced error object\n  const enhancedError = new Error(errorMessage);\n  enhancedError.originalError = error;\n  enhancedError.status = error.response?.status;\n  enhancedError.serverData = error.response?.data;\n  \n  throw enhancedError;\n};\n\n/**\n * Start a new interview session\n * @param {string} message - Initial user message\n * @param {string} userId - Optional user ID\n * @param {Object} jobRoleData - Optional job role configuration\n * @returns {Promise} Promise with response data\n */\nexport const startInterview = async (message, userId = null, jobRoleData = null) => {\n  try {\n    const requestBody = {\n      message,\n      user_id: userId\n    };\n    \n    // Add job role data if provided\n    if (jobRoleData) {\n      requestBody.job_role = jobRoleData.role_name;\n      requestBody.seniority_level = jobRoleData.seniority_level;\n      requestBody.required_skills = jobRoleData.required_skills;\n      requestBody.job_description = jobRoleData.description;\n    }\n    \n    const response = await api.post('/interview', requestBody);\n    return response.data;\n  } catch (error) {\n    return handleApiError(error, 'Failed to start interview');\n  }\n};\n\n/**\n * Continue an existing interview session\n * @param {string} message - User message\n * @param {string} sessionId - Interview session ID\n * @param {string} userId - User ID\n * @param {Object} jobRoleData - Optional job role configuration for new sessions\n * @returns {Promise} Promise with response data\n */\nexport const continueInterview = async (message, sessionId, userId, jobRoleData = null) => {\n  try {\n    if (!sessionId) {\n      throw new Error('Session ID is required');\n    }\n    \n    if (!userId) {\n      throw new Error('User ID is required');\n    }\n    \n    const requestBody = {\n      message,\n      user_id: userId\n    };\n    \n    // Add job role data if provided\n    if (jobRoleData) {\n      requestBody.job_role = jobRoleData.role_name;\n      requestBody.seniority_level = jobRoleData.seniority_level;\n      requestBody.required_skills = jobRoleData.required_skills;\n      requestBody.job_description = jobRoleData.description;\n    }\n    \n    const response = await api.post(`/interview/${sessionId}`, requestBody);\n    return response.data;\n  } catch (error) {\n    return handleApiError(error, 'Failed to continue interview');\n  }\n};\n\n/**\n * Get all sessions for a user\n * @param {string} userId - User ID\n * @param {boolean} includeCompleted - Whether to include completed sessions\n * @returns {Promise} Promise with response data\n */\nexport const getUserSessions = async (userId, includeCompleted = false) => {\n  try {\n    if (!userId) {\n      throw new Error('User ID is required');\n    }\n    \n    const response = await api.get(`/sessions/${userId}`, {\n      params: { include_completed: includeCompleted }\n    });\n    \n    return response.data;\n  } catch (error) {\n    return handleApiError(error, 'Failed to retrieve user sessions');\n  }\n};\n\n/**\n * Transcribe audio and get a response\n * @param {string} audioBase64 - Base64-encoded audio data\n * @param {string} userId - User ID\n * @param {string} sessionId - Optional session ID\n * @param {Object} jobRoleData - Optional job role configuration\n * @returns {Promise} Promise with response data\n */\nexport const transcribeAndRespond = async (audioBase64, userId, sessionId = null, jobRoleData = null) => {\n  try {\n    if (!audioBase64) {\n      console.error('DEBUG: Audio data is missing or empty');\n      throw new Error('Audio data is required');\n    }\n    \n    // Enhanced debugging for audio data\n    const isFullDataUri = audioBase64.startsWith('data:audio/');\n    const dataLength = audioBase64.length;\n    \n    console.log('DEBUG: Audio data stats:', {\n      totalLength: dataLength,\n      isDataUri: isFullDataUri,\n      prefix: audioBase64.substring(0, 30) + '...',\n      suffix: '...' + audioBase64.substring(audioBase64.length - 30)\n    });\n    \n    // Validate audio data format\n    if (!isFullDataUri && !audioBase64.match(/^[A-Za-z0-9+/=]+$/)) {\n      console.warn('DEBUG: Audio data does not appear to be valid base64 or data URI');\n    }\n    \n    // Ensure we use the full data URI for the backend\n    let formattedAudioData = audioBase64;\n    if (!isFullDataUri) {\n      // If we just got the base64 part, add the data URI prefix\n      console.log('DEBUG: Adding data URI prefix to raw base64 data');\n      formattedAudioData = `data:audio/wav;base64,${audioBase64}`;\n    }\n    \n    const requestBody = {\n      audio_data: formattedAudioData,\n      user_id: userId || `anon-${Date.now()}`,\n      session_id: sessionId,\n      sample_rate: 16000,  // Default sample rate\n      channels: 1          // Default channels\n    };\n    \n    // Log request size for debugging\n    console.log(`DEBUG: Sending transcription request with ${Math.round(formattedAudioData.length/1024)}KB audio data`);\n    \n    // Add job role data if provided\n    if (jobRoleData) {\n      requestBody.job_role = jobRoleData.role_name;\n      requestBody.seniority_level = jobRoleData.seniority_level;\n      requestBody.required_skills = jobRoleData.required_skills;\n      requestBody.job_description = jobRoleData.description;\n    }\n    \n    console.log('DEBUG: Sending audio transcription request...');\n    \n    // Create a custom config for the axios request with longer timeout\n    const requestConfig = {\n      timeout: 60000, // 60 seconds for audio processing\n      headers: {\n        'Content-Type': 'application/json',\n      }\n    };\n    \n    try {\n      const response = await api.post('/audio/transcribe', requestBody, requestConfig);\n      \n      // Validate response\n      if (!response.data || !response.data.transcription) {\n        console.error('DEBUG: Invalid response structure:', response.data);\n        throw new Error('Invalid response from transcription service');\n      }\n      \n      console.log('DEBUG: Transcription successful:', response.data.transcription);\n      return response.data;\n    } catch (requestError) {\n      console.error('DEBUG: Transcription request failed:', requestError);\n      \n      // Capture response data if available\n      if (requestError.response) {\n        console.error('DEBUG: Server response:', {\n          status: requestError.response.status,\n          data: requestError.response.data\n        });\n      }\n      \n      throw requestError;\n    }\n  } catch (error) {\n    // Special handling for 501 Not Implemented - voice processing not available\n    if (error.response && error.response.status === 501) {\n      console.error('DEBUG: Voice processing not available (501)');\n      const enhancedError = new Error('Voice processing is not available on this server');\n      enhancedError.isVoiceUnavailable = true;\n      throw enhancedError;\n    }\n    \n    // Special handling for 422 Unprocessable Entity - no speech detected\n    if (error.response && error.response.status === 422) {\n      console.error('DEBUG: No speech detected or transcription failed (422)');\n      const enhancedError = new Error('No speech detected or audio could not be transcribed');\n      enhancedError.isNoSpeech = true;\n      throw enhancedError;\n    }\n    \n    return handleApiError(error, 'Failed to process voice input');\n  }\n};\n\n/**\n * Check if voice processing is available on the server\n * @returns {Promise<boolean>} Promise resolving to true if voice processing is available, false otherwise\n */\nexport const checkVoiceAvailability = async () => {\n  try {\n    const response = await api.get('/health');\n    return response.data.voice_processing === 'available';\n  } catch (error) {\n    console.error('Error checking voice availability:', error);\n    return false;\n  }\n};\n\n/**\n * Submit code for a coding challenge\n * @param {string} challengeId - Challenge ID\n * @param {string} code - Candidate's code\n * @param {string} userId - User ID\n * @param {string} sessionId - Session ID\n * @returns {Promise} Promise with evaluation results\n */\nexport const submitChallengeCode = async (challengeId, code, userId = null, sessionId = null) => {\n  try {\n    if (!challengeId) {\n      throw new Error('Challenge ID is required');\n    }\n    \n    if (!code || code.trim() === '') {\n      throw new Error('Code solution is required');\n    }\n    \n    const requestBody = {\n      challenge_id: challengeId,\n      code: code,\n      user_id: userId,\n      session_id: sessionId\n    };\n    \n    const response = await api.post('/coding/submit', requestBody);\n    return response.data;\n  } catch (error) {\n    return handleApiError(error, 'Failed to submit code solution');\n  }\n};\n\n/**\n * Get a hint for the current coding challenge\n * @param {string} challengeId - Challenge ID\n * @param {string} code - Current code implementation\n * @param {string} userId - User ID\n * @param {string} sessionId - Session ID\n * @param {string} errorMessage - Optional error message to get specific help\n * @returns {Promise} Promise with hints\n */\nexport const getChallengeHint = async (challengeId, code, userId = null, sessionId = null, errorMessage = null) => {\n  try {\n    if (!challengeId) {\n      throw new Error('Challenge ID is required');\n    }\n    \n    const requestBody = {\n      challenge_id: challengeId,\n      code: code || '',\n      user_id: userId,\n      session_id: sessionId,\n      error_message: errorMessage\n    };\n    \n    const response = await api.post('/coding/hint', requestBody);\n    return response.data;\n  } catch (error) {\n    return handleApiError(error, 'Failed to get hint');\n  }\n};\n\n/**\n * Continue after completing a coding challenge\n * @param {string} message - User message (typically about the completed challenge)\n * @param {string} sessionId - Session ID\n * @param {string} userId - User ID\n * @param {boolean} completed - Whether the challenge was completed successfully\n * @returns {Promise} Promise with response data\n */\nexport const continueAfterCodingChallenge = async (message, sessionId, userId, completed = true) => {\n  try {\n    if (!sessionId) {\n      throw new Error('Session ID is required');\n    }\n    \n    if (!userId) {\n      throw new Error('User ID is required');\n    }\n    \n    const requestBody = {\n      message,\n      user_id: userId,\n      challenge_completed: completed\n    };\n    \n    const response = await api.post(`/interview/${sessionId}/challenge-complete`, requestBody);\n    return response.data;\n  } catch (error) {\n    return handleApiError(error, 'Failed to continue after challenge');\n  }\n};\n\n/**\n * Fetches available job roles for interviews\n * @returns {Promise<Array>} Array of job role objects\n */\nexport const getJobRoles = async () => {\n  try {\n    const response = await api.get('/job-roles');\n    return response.data;\n  } catch (error) {\n    return handleApiError(error, 'Failed to fetch job roles');\n  }\n};\n\n/**\n * Test audio transcription with a synthetic test tone\n * This function creates a test audio file with a clear beep sound and attempts to transcribe it\n * Useful for debugging if the transcription service is working properly\n * @returns {Promise} Promise with test results\n */\nexport const testAudioTranscription = async () => {\n  console.log('DEBUG: Starting audio transcription test');\n  \n  try {\n    // Create a test audio context\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    const oscillator = audioContext.createOscillator();\n    const gainNode = audioContext.createGain();\n    const destination = audioContext.createMediaStreamDestination();\n    \n    // Set up a clear beep tone\n    oscillator.type = 'sine';\n    oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4 note\n    gainNode.gain.setValueAtTime(0.8, audioContext.currentTime); // Loud enough to hear\n    \n    // Connect the nodes\n    oscillator.connect(gainNode);\n    gainNode.connect(destination);\n    \n    // Start the oscillator\n    oscillator.start();\n    \n    console.log('DEBUG: Created test tone generator');\n    \n    // Create a media recorder\n    const mediaRecorder = new MediaRecorder(destination.stream, {\n      mimeType: 'audio/webm',\n      audioBitsPerSecond: 128000\n    });\n    \n    const chunks = [];\n    mediaRecorder.ondataavailable = (e) => {\n      console.log('DEBUG: Test audio chunk received, size:', e.data.size);\n      chunks.push(e.data);\n    };\n    \n    // Record for 3 seconds\n    console.log('DEBUG: Recording test audio for 3 seconds');\n    \n    await new Promise((resolve) => {\n      mediaRecorder.onstop = resolve;\n      mediaRecorder.start();\n      \n      // Generate a sequence of tones for better recognition\n      setTimeout(() => oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime), 1000); // C5\n      setTimeout(() => oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime), 2000); // E5\n      \n      setTimeout(() => {\n        oscillator.stop();\n        mediaRecorder.stop();\n        console.log('DEBUG: Test audio recording completed');\n      }, 3000);\n    });\n    \n    // Create a blob from the chunks\n    const blob = new Blob(chunks, { type: 'audio/webm' });\n    console.log('DEBUG: Test audio blob created, size:', blob.size, 'bytes');\n    \n    // Convert the blob to base64\n    const base64 = await new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onloadend = () => resolve(reader.result);\n      reader.onerror = reject;\n      reader.readAsDataURL(blob);\n    });\n    \n    console.log('DEBUG: Test audio converted to base64, length:', base64.length);\n    \n    // Create a temporary audio element for debugging\n    const audio = new Audio(URL.createObjectURL(blob));\n    console.log('DEBUG: Test audio available at temporary URL:', audio.src);\n    \n    // Try to transcribe the test audio\n    console.log('DEBUG: Sending test audio for transcription');\n    const userId = 'test-user-' + Date.now();\n    \n    try {\n      const result = await transcribeAndRespond(base64, userId);\n      console.log('DEBUG: Test transcription successful!', result);\n      return {\n        success: true,\n        transcription: result.transcription,\n        audioSize: blob.size,\n        base64Length: base64.length\n      };\n    } catch (transcribeError) {\n      console.error('DEBUG: Test transcription failed', transcribeError);\n      return {\n        success: false,\n        error: transcribeError.message,\n        errorData: transcribeError.serverData,\n        audioSize: blob.size,\n        base64Length: base64.length\n      };\n    } finally {\n      // Clean up\n      audioContext.close();\n    }\n  } catch (error) {\n    console.error('DEBUG: Error creating test audio:', error);\n    return {\n      success: false,\n      error: error.message,\n      stage: 'audio_creation'\n    };\n  }\n};\n\n// Set up a response interceptor for global error handling\napi.interceptors.response.use(\n  response => response,\n  error => {\n    // Handle rate limiting errors (429)\n    if (error.response && error.response.status === 429) {\n      console.error('Rate limit exceeded:', error.response.data);\n      error.message = 'Too many requests. Please wait a moment before trying again.';\n    }\n    \n    // Handle server errors (500)\n    if (error.response && error.response.status >= 500) {\n      console.error('Server error:', error.response.data);\n      error.message = 'The server encountered an error. Please try again later.';\n    }\n    \n    return Promise.reject(error);\n  }\n);\n\n// Create a service object to export\nconst interviewService = {\n  startInterview,\n  continueInterview,\n  getUserSessions,\n  transcribeAndRespond,\n  checkVoiceAvailability,\n  submitChallengeCode,\n  getChallengeHint,\n  continueAfterCodingChallenge,\n  getJobRoles,\n  testAudioTranscription\n};\n\nexport default interviewService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}