{"ast":null,"code":"import{useState,useEffect,useCallback}from'react';import Recorder from'recorder-js';/**\n * Custom hook for audio recording functionality\n * @returns {Object} Object containing recording state and functions\n */const useAudioRecorder=()=>{const[recorder,setRecorder]=useState(null);const[stream,setStream]=useState(null);const[isRecording,setIsRecording]=useState(false);const[audioData,setAudioData]=useState(null);const[error,setError]=useState(null);const[audioContext,setAudioContext]=useState(null);// Clean up audio resources when the component unmounts\nuseEffect(()=>{return()=>{if(stream){// Stop all audio tracks\nstream.getTracks().forEach(track=>track.stop());}// Close audio context if it exists\nif(audioContext&&audioContext.state!=='closed'){audioContext.close();}};},[stream,audioContext]);// Initialize audio recording\nconst initRecording=useCallback(async()=>{try{setError(null);// Request user permission to access the microphone\nconst audioStream=await navigator.mediaDevices.getUserMedia({audio:true});setStream(audioStream);// Create an audio context\nlet context;try{context=new(window.AudioContext||window.webkitAudioContext)();setAudioContext(context);}catch(contextError){console.error('Error creating AudioContext:',contextError);throw new Error(`Could not create audio context: ${contextError.message}`);}// Create a new recorder with the audio context\nconst newRecorder=new Recorder(context,{onAnalysed:data=>{// You can use this callback to visualize the audio data\n// console.log('Audio data:', data);\n}});// Connect the recorder to the stream\nawait newRecorder.init(audioStream);// Save the recorder in state\nsetRecorder(newRecorder);return true;}catch(err){console.error('Error initializing audio recording:',err);setError(`Error accessing microphone: ${err.message}`);return false;}},[]);// Start recording\nconst startRecording=useCallback(async()=>{try{// If recorder doesn't exist, initialize it first\nif(!recorder){const initialized=await initRecording();if(!initialized)return false;// We need to wait for the next render cycle since setRecorder is async\n// This prevents trying to use the recorder before it's set in state\nreturn new Promise(resolve=>{setTimeout(async()=>{try{// By now the recorder should be set in state\nif(!recorder){throw new Error('Recorder not initialized properly');}recorder.start();setIsRecording(true);setAudioData(null);resolve(true);}catch(startErr){console.error('Error starting recorder after init:',startErr);setError(`Error starting recording: ${startErr.message}`);resolve(false);}},100);// Small delay to ensure state update has completed\n});}// If recorder already exists, start it directly\nrecorder.start();setIsRecording(true);setAudioData(null);return true;}catch(err){console.error('Error starting recording:',err);setError(`Error starting recording: ${err.message}`);return false;}},[recorder,initRecording]);// Stop recording and get the audio data\nconst stopRecording=useCallback(async()=>{if(!recorder||!isRecording)return null;try{const{blob,buffer}=await recorder.stop();setIsRecording(false);setAudioData({blob,buffer});return{blob,buffer};}catch(err){console.error('Error stopping recording:',err);setError(`Error stopping recording: ${err.message}`);return null;}},[recorder,isRecording]);// Convert audio blob to base64\nconst getAudioBase64=useCallback(async audioBlob=>{return new Promise((resolve,reject)=>{const reader=new FileReader();reader.onloadend=()=>{// Extract the base64 data from the result\n// The result is like \"data:audio/wav;base64,UklGRiXiAABXQVZF...\"\nconst base64Data=reader.result.split(',')[1];resolve(base64Data);};reader.onerror=reject;reader.readAsDataURL(audioBlob);});},[]);// Cancel recording\nconst cancelRecording=useCallback(()=>{if(recorder&&isRecording){recorder.cancel();setIsRecording(false);}setAudioData(null);},[recorder,isRecording]);return{isRecording,audioData,error,initRecording,startRecording,stopRecording,cancelRecording,getAudioBase64};};export default useAudioRecorder;","map":{"version":3,"names":["useState","useEffect","useCallback","Recorder","useAudioRecorder","recorder","setRecorder","stream","setStream","isRecording","setIsRecording","audioData","setAudioData","error","setError","audioContext","setAudioContext","getTracks","forEach","track","stop","state","close","initRecording","audioStream","navigator","mediaDevices","getUserMedia","audio","context","window","AudioContext","webkitAudioContext","contextError","console","Error","message","newRecorder","onAnalysed","data","init","err","startRecording","initialized","Promise","resolve","setTimeout","start","startErr","stopRecording","blob","buffer","getAudioBase64","audioBlob","reject","reader","FileReader","onloadend","base64Data","result","split","onerror","readAsDataURL","cancelRecording","cancel"],"sources":["/home/glitch/Documents/ai-interviewer/frontend/src/hooks/useAudioRecorder.js"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\nimport Recorder from 'recorder-js';\n\n/**\n * Custom hook for audio recording functionality\n * @returns {Object} Object containing recording state and functions\n */\nconst useAudioRecorder = () => {\n  const [recorder, setRecorder] = useState(null);\n  const [stream, setStream] = useState(null);\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioData, setAudioData] = useState(null);\n  const [error, setError] = useState(null);\n  const [audioContext, setAudioContext] = useState(null);\n\n  // Clean up audio resources when the component unmounts\n  useEffect(() => {\n    return () => {\n      if (stream) {\n        // Stop all audio tracks\n        stream.getTracks().forEach(track => track.stop());\n      }\n      \n      // Close audio context if it exists\n      if (audioContext && audioContext.state !== 'closed') {\n        audioContext.close();\n      }\n    };\n  }, [stream, audioContext]);\n\n  // Initialize audio recording\n  const initRecording = useCallback(async () => {\n    try {\n      setError(null);\n      \n      // Request user permission to access the microphone\n      const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      setStream(audioStream);\n      \n      // Create an audio context\n      let context;\n      try {\n        context = new (window.AudioContext || window.webkitAudioContext)();\n        setAudioContext(context);\n      } catch (contextError) {\n        console.error('Error creating AudioContext:', contextError);\n        throw new Error(`Could not create audio context: ${contextError.message}`);\n      }\n      \n      // Create a new recorder with the audio context\n      const newRecorder = new Recorder(context, {\n        onAnalysed: data => {\n          // You can use this callback to visualize the audio data\n          // console.log('Audio data:', data);\n        },\n      });\n\n      // Connect the recorder to the stream\n      await newRecorder.init(audioStream);\n      \n      // Save the recorder in state\n      setRecorder(newRecorder);\n      return true;\n    } catch (err) {\n      console.error('Error initializing audio recording:', err);\n      setError(`Error accessing microphone: ${err.message}`);\n      return false;\n    }\n  }, []);\n\n  // Start recording\n  const startRecording = useCallback(async () => {\n    try {\n      // If recorder doesn't exist, initialize it first\n      if (!recorder) {\n        const initialized = await initRecording();\n        if (!initialized) return false;\n        \n        // We need to wait for the next render cycle since setRecorder is async\n        // This prevents trying to use the recorder before it's set in state\n        return new Promise(resolve => {\n          setTimeout(async () => {\n            try {\n              // By now the recorder should be set in state\n              if (!recorder) {\n                throw new Error('Recorder not initialized properly');\n              }\n              recorder.start();\n              setIsRecording(true);\n              setAudioData(null);\n              resolve(true);\n            } catch (startErr) {\n              console.error('Error starting recorder after init:', startErr);\n              setError(`Error starting recording: ${startErr.message}`);\n              resolve(false);\n            }\n          }, 100); // Small delay to ensure state update has completed\n        });\n      }\n\n      // If recorder already exists, start it directly\n      recorder.start();\n      setIsRecording(true);\n      setAudioData(null);\n      return true;\n    } catch (err) {\n      console.error('Error starting recording:', err);\n      setError(`Error starting recording: ${err.message}`);\n      return false;\n    }\n  }, [recorder, initRecording]);\n\n  // Stop recording and get the audio data\n  const stopRecording = useCallback(async () => {\n    if (!recorder || !isRecording) return null;\n\n    try {\n      const { blob, buffer } = await recorder.stop();\n      setIsRecording(false);\n      setAudioData({ blob, buffer });\n      return { blob, buffer };\n    } catch (err) {\n      console.error('Error stopping recording:', err);\n      setError(`Error stopping recording: ${err.message}`);\n      return null;\n    }\n  }, [recorder, isRecording]);\n\n  // Convert audio blob to base64\n  const getAudioBase64 = useCallback(async (audioBlob) => {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onloadend = () => {\n        // Extract the base64 data from the result\n        // The result is like \"data:audio/wav;base64,UklGRiXiAABXQVZF...\"\n        const base64Data = reader.result.split(',')[1];\n        resolve(base64Data);\n      };\n      reader.onerror = reject;\n      reader.readAsDataURL(audioBlob);\n    });\n  }, []);\n\n  // Cancel recording\n  const cancelRecording = useCallback(() => {\n    if (recorder && isRecording) {\n      recorder.cancel();\n      setIsRecording(false);\n    }\n    setAudioData(null);\n  }, [recorder, isRecording]);\n\n  return {\n    isRecording,\n    audioData,\n    error,\n    initRecording,\n    startRecording,\n    stopRecording,\n    cancelRecording,\n    getAudioBase64,\n  };\n};\n\nexport default useAudioRecorder; "],"mappings":"AAAA,OAASA,QAAQ,CAAEC,SAAS,CAAEC,WAAW,KAAQ,OAAO,CACxD,MAAO,CAAAC,QAAQ,KAAM,aAAa,CAElC;AACA;AACA;AACA,GACA,KAAM,CAAAC,gBAAgB,CAAGA,CAAA,GAAM,CAC7B,KAAM,CAACC,QAAQ,CAAEC,WAAW,CAAC,CAAGN,QAAQ,CAAC,IAAI,CAAC,CAC9C,KAAM,CAACO,MAAM,CAAEC,SAAS,CAAC,CAAGR,QAAQ,CAAC,IAAI,CAAC,CAC1C,KAAM,CAACS,WAAW,CAAEC,cAAc,CAAC,CAAGV,QAAQ,CAAC,KAAK,CAAC,CACrD,KAAM,CAACW,SAAS,CAAEC,YAAY,CAAC,CAAGZ,QAAQ,CAAC,IAAI,CAAC,CAChD,KAAM,CAACa,KAAK,CAAEC,QAAQ,CAAC,CAAGd,QAAQ,CAAC,IAAI,CAAC,CACxC,KAAM,CAACe,YAAY,CAAEC,eAAe,CAAC,CAAGhB,QAAQ,CAAC,IAAI,CAAC,CAEtD;AACAC,SAAS,CAAC,IAAM,CACd,MAAO,IAAM,CACX,GAAIM,MAAM,CAAE,CACV;AACAA,MAAM,CAACU,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,EAAIA,KAAK,CAACC,IAAI,CAAC,CAAC,CAAC,CACnD,CAEA;AACA,GAAIL,YAAY,EAAIA,YAAY,CAACM,KAAK,GAAK,QAAQ,CAAE,CACnDN,YAAY,CAACO,KAAK,CAAC,CAAC,CACtB,CACF,CAAC,CACH,CAAC,CAAE,CAACf,MAAM,CAAEQ,YAAY,CAAC,CAAC,CAE1B;AACA,KAAM,CAAAQ,aAAa,CAAGrB,WAAW,CAAC,SAAY,CAC5C,GAAI,CACFY,QAAQ,CAAC,IAAI,CAAC,CAEd;AACA,KAAM,CAAAU,WAAW,CAAG,KAAM,CAAAC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC,CAAEC,KAAK,CAAE,IAAK,CAAC,CAAC,CAC9EpB,SAAS,CAACgB,WAAW,CAAC,CAEtB;AACA,GAAI,CAAAK,OAAO,CACX,GAAI,CACFA,OAAO,CAAG,IAAKC,MAAM,CAACC,YAAY,EAAID,MAAM,CAACE,kBAAkB,EAAE,CAAC,CAClEhB,eAAe,CAACa,OAAO,CAAC,CAC1B,CAAE,MAAOI,YAAY,CAAE,CACrBC,OAAO,CAACrB,KAAK,CAAC,8BAA8B,CAAEoB,YAAY,CAAC,CAC3D,KAAM,IAAI,CAAAE,KAAK,CAAC,mCAAmCF,YAAY,CAACG,OAAO,EAAE,CAAC,CAC5E,CAEA;AACA,KAAM,CAAAC,WAAW,CAAG,GAAI,CAAAlC,QAAQ,CAAC0B,OAAO,CAAE,CACxCS,UAAU,CAAEC,IAAI,EAAI,CAClB;AACA;AAAA,CAEJ,CAAC,CAAC,CAEF;AACA,KAAM,CAAAF,WAAW,CAACG,IAAI,CAAChB,WAAW,CAAC,CAEnC;AACAlB,WAAW,CAAC+B,WAAW,CAAC,CACxB,MAAO,KAAI,CACb,CAAE,MAAOI,GAAG,CAAE,CACZP,OAAO,CAACrB,KAAK,CAAC,qCAAqC,CAAE4B,GAAG,CAAC,CACzD3B,QAAQ,CAAC,+BAA+B2B,GAAG,CAACL,OAAO,EAAE,CAAC,CACtD,MAAO,MAAK,CACd,CACF,CAAC,CAAE,EAAE,CAAC,CAEN;AACA,KAAM,CAAAM,cAAc,CAAGxC,WAAW,CAAC,SAAY,CAC7C,GAAI,CACF;AACA,GAAI,CAACG,QAAQ,CAAE,CACb,KAAM,CAAAsC,WAAW,CAAG,KAAM,CAAApB,aAAa,CAAC,CAAC,CACzC,GAAI,CAACoB,WAAW,CAAE,MAAO,MAAK,CAE9B;AACA;AACA,MAAO,IAAI,CAAAC,OAAO,CAACC,OAAO,EAAI,CAC5BC,UAAU,CAAC,SAAY,CACrB,GAAI,CACF;AACA,GAAI,CAACzC,QAAQ,CAAE,CACb,KAAM,IAAI,CAAA8B,KAAK,CAAC,mCAAmC,CAAC,CACtD,CACA9B,QAAQ,CAAC0C,KAAK,CAAC,CAAC,CAChBrC,cAAc,CAAC,IAAI,CAAC,CACpBE,YAAY,CAAC,IAAI,CAAC,CAClBiC,OAAO,CAAC,IAAI,CAAC,CACf,CAAE,MAAOG,QAAQ,CAAE,CACjBd,OAAO,CAACrB,KAAK,CAAC,qCAAqC,CAAEmC,QAAQ,CAAC,CAC9DlC,QAAQ,CAAC,6BAA6BkC,QAAQ,CAACZ,OAAO,EAAE,CAAC,CACzDS,OAAO,CAAC,KAAK,CAAC,CAChB,CACF,CAAC,CAAE,GAAG,CAAC,CAAE;AACX,CAAC,CAAC,CACJ,CAEA;AACAxC,QAAQ,CAAC0C,KAAK,CAAC,CAAC,CAChBrC,cAAc,CAAC,IAAI,CAAC,CACpBE,YAAY,CAAC,IAAI,CAAC,CAClB,MAAO,KAAI,CACb,CAAE,MAAO6B,GAAG,CAAE,CACZP,OAAO,CAACrB,KAAK,CAAC,2BAA2B,CAAE4B,GAAG,CAAC,CAC/C3B,QAAQ,CAAC,6BAA6B2B,GAAG,CAACL,OAAO,EAAE,CAAC,CACpD,MAAO,MAAK,CACd,CACF,CAAC,CAAE,CAAC/B,QAAQ,CAAEkB,aAAa,CAAC,CAAC,CAE7B;AACA,KAAM,CAAA0B,aAAa,CAAG/C,WAAW,CAAC,SAAY,CAC5C,GAAI,CAACG,QAAQ,EAAI,CAACI,WAAW,CAAE,MAAO,KAAI,CAE1C,GAAI,CACF,KAAM,CAAEyC,IAAI,CAAEC,MAAO,CAAC,CAAG,KAAM,CAAA9C,QAAQ,CAACe,IAAI,CAAC,CAAC,CAC9CV,cAAc,CAAC,KAAK,CAAC,CACrBE,YAAY,CAAC,CAAEsC,IAAI,CAAEC,MAAO,CAAC,CAAC,CAC9B,MAAO,CAAED,IAAI,CAAEC,MAAO,CAAC,CACzB,CAAE,MAAOV,GAAG,CAAE,CACZP,OAAO,CAACrB,KAAK,CAAC,2BAA2B,CAAE4B,GAAG,CAAC,CAC/C3B,QAAQ,CAAC,6BAA6B2B,GAAG,CAACL,OAAO,EAAE,CAAC,CACpD,MAAO,KAAI,CACb,CACF,CAAC,CAAE,CAAC/B,QAAQ,CAAEI,WAAW,CAAC,CAAC,CAE3B;AACA,KAAM,CAAA2C,cAAc,CAAGlD,WAAW,CAAC,KAAO,CAAAmD,SAAS,EAAK,CACtD,MAAO,IAAI,CAAAT,OAAO,CAAC,CAACC,OAAO,CAAES,MAAM,GAAK,CACtC,KAAM,CAAAC,MAAM,CAAG,GAAI,CAAAC,UAAU,CAAC,CAAC,CAC/BD,MAAM,CAACE,SAAS,CAAG,IAAM,CACvB;AACA;AACA,KAAM,CAAAC,UAAU,CAAGH,MAAM,CAACI,MAAM,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAC9Cf,OAAO,CAACa,UAAU,CAAC,CACrB,CAAC,CACDH,MAAM,CAACM,OAAO,CAAGP,MAAM,CACvBC,MAAM,CAACO,aAAa,CAACT,SAAS,CAAC,CACjC,CAAC,CAAC,CACJ,CAAC,CAAE,EAAE,CAAC,CAEN;AACA,KAAM,CAAAU,eAAe,CAAG7D,WAAW,CAAC,IAAM,CACxC,GAAIG,QAAQ,EAAII,WAAW,CAAE,CAC3BJ,QAAQ,CAAC2D,MAAM,CAAC,CAAC,CACjBtD,cAAc,CAAC,KAAK,CAAC,CACvB,CACAE,YAAY,CAAC,IAAI,CAAC,CACpB,CAAC,CAAE,CAACP,QAAQ,CAAEI,WAAW,CAAC,CAAC,CAE3B,MAAO,CACLA,WAAW,CACXE,SAAS,CACTE,KAAK,CACLU,aAAa,CACbmB,cAAc,CACdO,aAAa,CACbc,eAAe,CACfX,cACF,CAAC,CACH,CAAC,CAED,cAAe,CAAAhD,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}