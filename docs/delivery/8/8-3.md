# 8-3 Build LangGraph Integration Adapter

[Back to task list](./tasks.md)

## Description

Create an integration adapter that bridges the Gemini Live API responses with the existing LangGraph interview logic. This adapter will translate real-time conversation events into LangGraph state updates and tool calls while preserving all existing interview stages, memory management, and session persistence.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-01-27 16:10:00 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2025-01-27 16:15:00 | Status Change | Proposed | Agreed | Task approved for implementation | User |
| 2025-01-27 16:20:00 | Status Change | Agreed | InProgress | Started implementation of LangGraph Integration Adapter | AI_Agent |
| 2025-01-27 16:45:00 | Status Change | InProgress | Review | Implementation completed, ready for review | AI_Agent |
| 2025-01-27 16:50:00 | Status Change | Review | Done | Implementation approved and completed | User |

## Requirements

### Functional Requirements
1. **LangGraph State Management**
   - Monitor and update InterviewState from real-time conversations
   - Handle stage transitions triggered by conversation flow
   - Maintain session persistence with MongoDB

2. **Tool Call Integration**
   - Detect when LangGraph tools should be called (coding challenges, feedback, etc.)
   - Execute tool calls asynchronously without blocking audio stream
   - Inject tool results back into conversation context

3. **Event Bridge**
   - Convert Gemini Live API events to LangGraph-compatible format
   - Handle conversation summaries and memory management
   - Maintain interview flow integrity

### Technical Requirements
1. **Dependencies**: Integration with existing AIInterviewer, ContextInjectionService, GeminiLiveAudioAdapter
2. **Performance**: Tool calls should not block real-time audio (<500ms processing)
3. **State Sync**: Ensure InterviewState remains consistent across components
4. **Error Handling**: Graceful degradation when tools fail

## Implementation Plan

### Phase 1: Core Integration Adapter
```python
# File: ai_interviewer/services/langgraph_integration_adapter.py

class LangGraphIntegrationAdapter:
    def __init__(self, ai_interviewer: AIInterviewer, 
                 context_service: ContextInjectionService,
                 gemini_adapter: GeminiLiveAudioAdapter):
        self.ai_interviewer = ai_interviewer
        self.context_service = context_service
        self.gemini_adapter = gemini_adapter
        
    async def handle_conversation_turn(self, audio_response: str, 
                                     current_state: InterviewState):
        """Process a conversation turn through LangGraph logic"""
        
    async def trigger_tool_call(self, tool_name: str, 
                              tool_args: Dict[str, Any]):
        """Execute LangGraph tool and inject results"""
        
    async def update_interview_stage(self, new_stage: str, 
                                   context: Dict[str, Any]):
        """Handle interview stage transitions"""
```

### Phase 2: State Synchronization
- Implement bidirectional state sync between real-time API and LangGraph
- Handle conversation history and memory management
- Maintain session metadata consistency

### Phase 3: Tool Call Detection and Execution
- Analyze conversation for tool trigger patterns
- Execute tools asynchronously in background
- Inject results via ContextInjectionService

## Verification

### Unit Tests
1. **State Management**
   - Test InterviewState updates from conversation events
   - Verify stage transition detection and handling
   - Test session persistence with MongoDB

2. **Tool Integration**
   - Test tool call detection from conversation patterns
   - Verify tool execution and result injection
   - Test error handling for failed tool calls

3. **Event Processing**
   - Test conversation turn processing
   - Verify memory management and summarization
   - Test performance under load

### Integration Tests
1. **End-to-End Flow**
   - Test complete interview with real-time API and LangGraph
   - Verify all interview stages work correctly
   - Test tool calls during real-time conversation

2. **Performance Testing**
   - Test tool call latency (<500ms)
   - Verify no audio interruption during tool execution
   - Test memory usage during long interviews

## Files Modified

- `ai_interviewer/services/langgraph_integration_adapter.py` (new)
- `ai_interviewer/services/__init__.py` (updated)
- `ai_interviewer/core/ai_interviewer.py` (modified - integration hooks)
- `tests/unit/services/test_langgraph_integration_adapter.py` (new)
- `tests/integration/test_realtime_langgraph_bridge.py` (new)

## Test Plan

### Integration Scenarios
1. **Interview Flow**: Start session → stage transitions → tool calls → conclusion
2. **Tool Execution**: Coding challenge generation and submission during real-time conversation
3. **State Persistence**: Session resume with correct state restoration
4. **Error Recovery**: Handle tool failures gracefully without breaking conversation

### Success Criteria
- All interview stages work with real-time API
- Tool calls execute within 500ms without audio interruption
- InterviewState remains consistent across components
- Session persistence works correctly with MongoDB
- Memory management functions properly during long conversations 